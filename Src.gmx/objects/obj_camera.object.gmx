<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>-10000</depth>
  <persistent>0</persistent>
  <parentName>par_controller</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Set up Variables.
  
 // Width/Height:
    _W = global.ScreenWidth;
    _H = global.ScreenHeight;
    
 // Set view:
    view_object [0] = id;
    view_hborder[0] = _W/2;
    view_vborder[0] = _H/2;

 // Create a rectangle around the subject that the subject must exceed before the camera will move. Like the Genesis games!
    Cam_LeftBorder   = x-8;
    Cam_RightBorder  = x+8;
    Cam_TopBorder    = y-32;
    Cam_BottomBorder = y+32;

 // Additional
    Cam_Subject    = par_character; // who is the camera following? (most often it's the player)
    Cam_CameraLock = false;         // whether the cam is locked from moving
    
 // Limits. You can can't go outside these boundaries 
    Cam_LeftLimit   = 0;
    Cam_RightLimit  = room_width;
    Cam_TopLimit    = 0;
    Cam_BottomLimit = room_height;

 // Camera Binding:   
    Cam_BindX = false;
    Cam_MinX = 0;
    Cam_MaxX = room_width;
    
 // Camera Lag:
    Cam_Lag = 0;

 // Define Camera Position. We used temp variables xx and yy to help with Shifting while looking up/down etc
    Cam_XX = x;
    Cam_YY = y;

 // Shifting variables:
    Cam_ShiftX     = 0; // Camera Shift X Value.
    Cam_ShiftY     = 0; // Camera Shift Y Value.
    Cam_ShiftSpeed = 2; // Shifting speed.
    
 // Speed at wich to change target/subject
    Cam_ChangeSpeed = 6.5;

 // Special functions.
    Camera_ShakeScreen   = false;              // If enabled, the screen will shake as long as _ShakeDuration is above 0.
    Camera_ShakeDuration = 0;                  // How many frames the Shaking lasts.
    Camera_ShakeForce    = 0;                  // The force of the Shake, 2 to 3 is a good number, everything above 3 is a strong shake.
    Camera_ShakeSound    = snd_object_crumble; // If not set to noone, the game will loop this sound until the shake is over.
    Camera_DebugDisplay  = false;              // Displays Debug Graphics.         


</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="2">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Shift the Camera Up or Down.

    // Only run this if we follow the Character:
       if(Cam_Subject == par_character){
       
          // Looking up:
          if(Cam_Subject.Action == ActionLookup &amp;&amp; Cam_Subject.TimerUp &gt;= 120)        
              Cam_ShiftY = max(-104, Cam_ShiftY-2);
          // Looking Down:
          else if(Cam_Subject.Action == ActionCrouch &amp;&amp; Cam_Subject.TimerDown &gt;= 120)       
              Cam_ShiftY = min(104, Cam_ShiftY+2);                  
          else
              Cam_ShiftY = max(0, abs(Cam_ShiftY)-2)*sign(Cam_ShiftY);      

          // Pan the camera horizintally if the character is using a peelout move.
             if((Cam_Subject.Action == ActionPeelout &amp;&amp; Cam_Subject.PeeloutTimer &gt; 6) || Cam_Subject.PeeloutFlag == 1){
                var _dir = sign(Cam_Subject.XSpeed + Cam_Subject.AnimationDirection);
                Cam_ShiftX = clamp((abs(Cam_ShiftX) + Cam_ShiftSpeed) * _dir, -64, 64);
             }else{
                Cam_ShiftX = max(0, abs(Cam_ShiftX)-2)*sign(Cam_ShiftX); 
             }
                           
       }

</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Main Camera Control

//Update borders
Cam_LeftBorder   = (Cam_XX-8) - (Cam_Lag);
Cam_RightBorder  = (Cam_XX+8) + (Cam_Lag);
Cam_TopBorder    = Cam_YY-32;
Cam_BottomBorder = Cam_YY+32;


//set up some local variables to make for neat-looking code
var VW = (view_wview[0])/2;
var VH = (view_hview[0])/2;


//Move the Camera
if Cam_Subject = par_character
{
    //1. HORIZTONAL MOVEMENT
    //if Player has exceed the right border, move the camera by the amount exceeded
    if (Cam_Subject.x &gt; Cam_RightBorder &amp;&amp; Cam_Subject.x &lt;= (Cam_RightLimit-VW))
    {
        Cam_XX += min(abs(Cam_Subject.x-Cam_RightBorder),16);
    }
    
    //if Player has exceed the left border, move the camera by the amount exceeded
    if (Cam_Subject.x &lt; Cam_LeftBorder+Cam_Lag &amp;&amp; Cam_Subject.x &gt;= (Cam_LeftLimit+VW))
    {
        Cam_XX -= min(abs(Cam_LeftBorder+Cam_Lag-Cam_Subject.x),16);
    }
    
    //2. VERTICAL MOVEMENT
    //in the air....
    if (Cam_Subject.Ground == false &amp;&amp; Cam_Subject.Action != ActionDie)
    {
        //if Player has exceed the bottom border, move the camera by the amount exceeded
        if (Cam_Subject.y &gt; Cam_BottomBorder &amp;&amp; Cam_Subject.y &lt; Cam_BottomLimit-VH)
        {
            Cam_YY += Cam_Subject.y-Cam_BottomBorder;
        }
        
        //if Player has exceed the top border, move the camera by the amount exceeded
        if (Cam_Subject.y &lt; Cam_TopBorder &amp;&amp; Cam_Subject.y &gt; Cam_TopLimit+VH)
        {
            Cam_YY -= Cam_TopBorder-Cam_Subject.y;
        }
    }
    
    //on the ground
    if (Cam_Subject.Ground == true &amp;&amp; Cam_Subject.Action != ActionDie)
    {
        //if player is not centered vertically
        if Cam_Subject.y != Cam_YY
        {
            //this creates the camera lag when you land after a jump
            if abs(Cam_Subject.y-Cam_Subject.yprevious) &lt;= 6 //if sonic has only moved six of less pixels from the previous frame. The reason we use yprevious instead of YSpeed is because we have to account for slopes, in which Sonic technically moving vertically, despite his YSpeed being zero.
            {
                if (Cam_Subject.y &gt; Cam_YY &amp;&amp; Cam_Subject.y &lt; Cam_BottomLimit-VH)
                Cam_YY += min(abs(Cam_Subject.y-Cam_YY),6);
                
                
                if (Cam_Subject.y &lt; Cam_YY &amp;&amp; Cam_Subject.y &gt; Cam_TopLimit+VH)
                Cam_YY -= min(abs(Cam_YY-Cam_Subject.y),6);
            }
            
            //this keeps thing mostly centered when going on loops and slopes, though there is a limit... 
            //...if Sonic is moving vertically faster than 16 px, he will "outrun" the camera. this is denoted by the min function
            if abs(Cam_Subject.y-Cam_Subject.yprevious) &gt; 6
            {
                if (Cam_Subject.y &gt; Cam_YY &amp;&amp; Cam_Subject.y &lt; Cam_BottomLimit-VH)
                Cam_YY += min(abs(Cam_Subject.y-Cam_YY),16);
                
                
                if (Cam_Subject.y &lt; Cam_YY &amp;&amp; Cam_Subject.y &gt; Cam_TopLimit+VH)
                Cam_YY -= min(abs(Cam_YY-Cam_Subject.y),16);
            }
        }
    }

}

//Otherwise, if the camera is not looking at the player, but at an NPC or something ( like a boss fight)
if (Cam_Subject != noone &amp;&amp; Cam_Subject != par_character)
{
//if target is not centered horizontally
if Cam_Subject.x != Cam_XX
{

if (Cam_Subject.x &gt; Cam_XX &amp;&amp; Cam_XX &lt;= Cam_RightLimit-VW)
    Cam_XX += min(abs(Cam_Subject.x-Cam_XX),Cam_ChangeSpeed);


if (Cam_Subject.x &lt; Cam_XX &amp;&amp; Cam_XX &gt;= Cam_LeftLimit+VW)
    Cam_XX -= min(abs(Cam_XX-Cam_Subject.x),Cam_ChangeSpeed);
}



//if target is not centered vertically
if Cam_Subject.y != Cam_YY
{

if (Cam_Subject.y &gt; Cam_YY &amp;&amp; Cam_YY &lt; Cam_BottomLimit-VH)
    Cam_YY += min(abs(Cam_Subject.y-Cam_YY),Cam_ChangeSpeed);


if (Cam_Subject.y &lt; Cam_YY &amp;&amp; Cam_YY &gt; Cam_TopLimit+VH)
    Cam_YY -= min(abs(Cam_YY-Cam_Subject.y),Cam_ChangeSpeed);
}


}

///Update position
x = Cam_XX + Cam_ShiftX + random_range(-Camera_ShakeForce, Camera_ShakeForce); 
y = Cam_YY + Cam_ShiftY + random_range(-Camera_ShakeForce, Camera_ShakeForce);





</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Camera Shake.

    if(Camera_ShakeScreen = true){
       if(Camera_ShakeDuration != 0){
          if(CheckSound(Camera_ShakeSound) == false){
             LoopSound(Camera_ShakeSound, global.SFXVolume, 1);
          }
          Camera_ShakeDuration--         
       }else{
          if(CheckSound(Camera_ShakeSound) == true){
             StopSound(Camera_ShakeSound);
          }      
          Camera_ShakeScreen = false;   
          Camera_ShakeForce  = 0; 
       }
    }
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Camera lag timer.
    if(Cam_Lag &gt; 0){
       Cam_Lag -= 3;
    }else{
       Cam_Lag = 0;
    }
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="4">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Set position.

    x      = par_character.x;
    y      = par_character.y;
    Cam_XX = par_character.x;
    Cam_YY = par_character.y;
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
