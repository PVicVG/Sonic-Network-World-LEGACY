<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>spr_icon_character</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>obj_character</parentName>
  <maskName>spr_mask_main</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>other</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Create and define most common character values.
global.main_player = self;
ai_flag = false;
   // Set the Chracter ID:
      CharacterID    = global.Character_1; // Who we're playing as.
      CharacterState = CharacterNormal;    // State of our Character, either Normal (Default), Super or Hyper.
      CharacterType  = IsPlayable;         // Is Playable or AI?
      allow_lightdash     = global.use_light;   // Set to false to disable Lightdash.
      // Light Dash //
    using_lightdash = false             //Checks if you're using the Lightdash.
      
   // Horizontal Speed Values:
      XSpeed          = 0;        // The current horizontal speed.
      XSpeed_Top      = 6;        // Characters top horizontal speed when on flat ground.
      XSpeed_Max      = 16;       // Fastest the Character can move horizontally.
      GSpeed          = 0;        // Temp. Variable to store X or Y Speed.       
      XAcceleration   = 0.046875; // Horizontal acceleration and friction when on ground.
      XDeceleration   = 0.5;      // Horizontal deceleration when opposite input is held.
      XSlopeFactor    = 0.125;    // Rate at which the character slows down when moving up slopes. //0.5;
      AirAccel        = 0.09375   // Acceleration value in air.
      _Accel          = 0;        // Temp. acceleration variable.
      _Decel          = 0;        // Temp. deceleration variable.
      _Fric           = 0;        // Temp. friction variable.
      SpeedLimit      = false;    // Whether or not we limit the Horizontal Speed.
      Allow_XMovement = true;     // Whether or not we allow the Horizontal movement.
      SpeedShoeTimer  = 900;      // How long Speed shoes last.       
      
   // Vertical Speed Values:
      YSpeed         = 0;        // The current vertical speed.
      YSpeed_Max     = 16;       // Fastest the player can move/fall vertically.
      YAcceleration  = 0.21875;  // The force of gravity applied to the character while ion the air.
      YAccel_Common  = 0.21875;  // Common/Default force of acceleration. In case we have to reset it quickly.
      ConversionFact = 1;        // Speed conversion when landing on ground.
      AirLimit       = true;     // Whether or not we limit the Vertical Speed.
      AirTimer       = 0;        // Checks how long we're in the air.
      Allow_YMovement = true;    // Whether or not we allow the Vertical movement.

   // Other movement variables
      XSample        = 13;       // Pixel limit to divide horizontal movement; ignored if 0 or less
      YSample        = 13;       // Pixel limit to divide vertical movement; ignored if 0 or less

   // Terain interaction:
      Ground              = false;    // Checks if the character has/is grounded.
      PlatformCheck       = false;    // Checks if the character has landed on a platform.
      PlatformCheckTimer  = 30;       // Used to reset the Platform check. Prevents that the character looses collision.
      OnSwing             = noone;    // Checks if the character is on a swinging platform.
      OnMoving            = noone;    // Checks if the character is on a moving platform.
      OnCollapse          = noone;    // Checks if the character is on a collapsing tile.
      AllowStuck          = noone;    // If true, this will prevent the "Stuck in terrain" code.
      Angle               = 0;        // Angle of the terrain.
      AngleRound          = 0;        // Rounded angle.
      RelativeAngle       = 0;        // Current angle relative to the gravity angle.    
      AngleHold           = 0;        // Used for smoothing angle values.
      AnimationAngle      = 0;        // Used to rotate the characters sprite.
      Layer               = 0;        // Characters collision layer. Used for loops and special paths.

   // Control Flags: 
      InputAlarm     = 0;        // Used for locking input temporarly when loosing speed on step slopes.
      AlarmDirection = 0;        // For the above variable, this one locks either the right or left key.
      InputLock_L    = 0;        // Is the left input locked?
      InputLock_R    = 0;        // Is the right input locked?
      InputLock_S    = 0;        // Is the input locked after using a spring?      
      LockTimer      = 0;        // Keep track how long the input is locked.
      LockControl    = 1;        // Looks the control.
      LockTunnel     = 0;        // Locks falling when inside a tunnel.      
      Launched       = 0;        // Whether or not we launched up in the air (using a slope)
      LaunchedTimer  = 0;        // Makes sure to disable any kind of horizontal force when being launched.
      JumpLock       = 0;        // Used to lock the jumping direction.
      AllowLookUp    = 1;        // Checks if we're allowed to look up.
      AllowLookDown  = 1;        // Checks if we're allowed to look down.
      UsedCorkscrew  = 0;        // Used after a Corkscrew to revert changes made to the character.
      ai_flag             = false;
      
   // Special/Character Specific Abilities and flags:
      AbilityPeelout  = 1;       // Can we use the Peelout?
      PeeloutFlag     = 0;       // Checks if we're performing a peelout.
      PeeloutTimer    = 0;       // Has to be 12 to perform a peelout.
      AbilityGrind    = 0;       // Can we grind on rails?
      AbilityBoost    = 0;       // Can we boost?
      AbilityHoming   = 1;       // Can we perform a homing attack?
      HomingTable     = 0;       // Contains the objects we can target.
      HomingUsed      = 0;       // Checks if we're used a homing attack.
      AbilityTricks   = 0;       // Can we perform tricks?
      AbilityDropDash = 1;       // Can we perform a drop dash?
      DropDashFlag    = 0;       // Used to change the animation.
      DropDashTimer   = 15;      // How long it takes to charge the drop dash.
      DropDashSpeed   = 0;       // How strong the drop dash is. 
      
      // Homing Attack //
    use_homing          = false;        // Whether or not the player can perform the homing attack.
    homing_dist         = 128;          // The max distance the player can be from a target to do the homing attack.
    homing_id           = noone;        // Instance ID of the homing object.
    homing_speed        = 8;            // How quickly the player homes on to the target.
      
   // Camera:
      Offset_Up      = -104;     // How many pixels the camera will move up while looking up.
      Offset_Down    = 88;       // How many pixels the camera will mvoe down while crouching.
      Offset_Hor     = 60;       // Horizontal offset.
      TimerUp        = 0;        // Keeps track of how long the character has been looking up.
      TimerDown      = 0;        // Keeps track of how long the character has been looking down.
      TimerDash      = 0;        // Keeps track of how long the character has been spindashing.
      ShiftX         = 0;        // How much the camera shifts on the x-axis.
      PreviousX      = x;        // Previous X Position.
      PreviousY      = y;        // Previous Y Position.
      BindToCam      = false;    // Whether or not the character can leave the boundaries. 
             
   // World interaction:
      Underwater     = false;    // Checks if the character is underwater.
      DrownTimer     = 1800;     // How long it takes (in frames) for the character to drown.
      DrownCounter   = -1;       // The number count down above the character while about to drown.
      BubbleTimer    = 0;        // How long the character is stuck in the breathing state after touching a bubble.
      BreathTimer    = 20;       // Needed for creating bubbles after we drowned.
      HasDrowned     = false;    // Checks if the Character has drowned.
      Invincibility  = 0;        // Check whether or not the character is invincible. (1 - When Hurt, 1.5 - When having a invincibility shield, 2 - When Super/Hyper)
      InvTimer       = 0;        // How long the invincibility last.
      Shield         = 0;        // The current shield of the Character.
      ShieldChild    = 0;        // Needed to destroy/change a shield.
      ShieldBackup   = 0;        // Used when in super/hyper form and getting a shield.
      ShieldUsable   = 0;        // Whether or not we can use a shield.
      ShieldAttack   = 0;        // Checks if we're attacking using a shield.
      ShieldCoolDown = 0;        // Prevent insta-use of electricity shield on ceilings.
      FloorMode      = 0;        // Returns the floor mode.
       
   // Rendering:
      FramesCount     = 0;       // Used for various animations. Like count frames when no input is given and the character is doing nothing.
      FrameHold       = 0;       // Holds the number of a frame, used after the character turns back to normal after their super/hyper form.
      RenderingSpeed  = 0;       // Used to modify the speed of various animations.
      SnapTimer       = 0;       // Used to rotate the Character properly in 8Â°Mode.
      PalettePosition = 0;       // If we manipulate a sprites palette, this keeps track of the position.  
      Rotation_Animation = 0;    // Used when the character has to use a rotation animation (ex. corkscrew) 
      Rotation_Speed  = 0.25;    // Used for rotation animations.
      Rotation_Frame  = 0;       // Used for rotation animations, but if we manually want to change the frame.
      Alpha           = 1;       // The opacity of the characters sprite.
      XLen            = 1;       // The X Length value used for drawing sparks.
      YLen            = 0;       // The Y Length value used for drawing sparks.

   // State:
      Action         = 0;        // Keeps track of the current action/state.
      
   // Physic Modifications:
      PhysicMode     = "Normal"; // Whether we're using default physics, water physics or super physics.
      HasSpeedShoes  = false;    // Checks whether or not we got speed shoes.
   
   // Jumping:
   
      JumpStrength   = -6.5;     // Strength of the characters jump.
      JumpRelease    = -4;       // The minimum strength the character can jump.
      JumpHeightMod  = true;     // Whether or not we can modify the jump height.
      
   // Rolling:
      RollDec        = 0.3;       // Rolling deceleration.
      RollDecLight   = 0.0234375; // Deceleration when holding the forward direction.
      RollDecStrong  = 0.125;     // Deceleration when holding the opposite direction.
      Rolling_Deceleration_Up   = 0.078125; // Slope decel. factor when rolling up.
      Rolling_Deceleration_Down = 0.3125;   // Slope decel. factor when rollong down.
      
   // Spindash:
      SpindashAccumulator =  0;   // Spindash accumlator.
      SpindashAccumMax    =  12;  // Max. accumlator amount.
      SpindashAccumMin    =  8;   // Min. ammount needed to perform a spindash.
      SpindashPitch       =  0;   // How much the spindash sounds pitch gets increased.
      
   // Pushing:
      Pushing_Timer       = 0;    // Keeps track how long we're already trying to push.
      Pushing_Timer_Max   = 3;    // How long it takes to actually push.
      
   // Skidding:
      SkiddingFrames      = 80;   // How long you can skid.
      SkidDirection       = 1;
    
   // Goal:
      GoalState           = 0;    // Check if we're in our goal state. (Results)
      GoalTimer           = 5;    // Keeps track how many frames it takes to stop sonic from movement.
   
   // Flying:
      FlightTimer         = 0;
      FlightDuration      = 480;
      FlySoundTimer       = 0;
      FlySoundControl     = 0;      
      FlyFallControl      = 0

   // (Amy only) - Hammer and dif. Jumps.
      AmyHammerAttack    = 0;    // Sets the Hammer attack for Amy. (0 = No attack, 1 = Standing Attack, 2 = Running Attack, 3 = Air Attack)
      AmyRollJump        = 0;    // Used to change Amy's animation.
      AmyHammerJump      = 0;    // Used when doing a hammer jump.
      AmyDashDirection   = 0;    // Used when doing a hammer dash.
   
   // (Knuckles only) - Gliding and Climbing.
      GlideTopSpeed      = 24;   // Fastest Knuckles can move horizontally while gliding.
      GlideGravity       = .125; // The gravity while gliding.
      GlideCrouchTimer   = 25;   // How long knuckles stays in his crouched state.
      GlideTurn_S        = 0;    // Special variable for turning knuckles.
      GlideTurn_A        = 0;    // Special variable for turning knuckles.
      GlideTurn_D        = 0;    // Special variable for turnuing knuckles.
      ClimbOX            = 0;    // Position returns the x position when grabbing onto a wall. If the X value is lower/higher, stop climbing.
      ClimbSpeed         = 1;    // How fast Knuckles can climb a wall.
      ClimbFrameTimer    = 6;    // When 0, advance the frame of knuckles climb animation.
      IsLedgeGrabbing    = 0;    // Checks if we're ledge grabbing.
                        
   // Transforming
      AllowTransformation = 1;    // Checks if we can transform.
      TransformEnded      = 0;    // Checks if a transformation has ended. 
      if(CharacterID != CharacterKnuckles){
         TransformTimer      = 15;   // How long it takes to return to a normal stage.
      }else{
         TransformTimer      = 3;   // How long it takes to return to a normal stage.         
      }
         
   // Death:
      DeathTimer          = "NO"; // Dying timer.

</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Input Keys.
scr_input()
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Define Animation system.
   scr_animation_init();
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Checkpoint Respawn &amp; Bonus Stage Rewards.
    if(global.BonusStage == false){
       if(global.CheckpointX != -1 &amp;&amp; global.CheckpointY != -1){
          x = global.CheckpointX;
          y = global.CheckpointY;
          if(global.BonusRings != 0){
             global.Rings     += global.BonusRings;
             global.BonusRings = 0;
          }
          if(global.BonusShield != 0){             
             Shield = global.BonusShield;
             global.BonusShield  = 0;
          }  
             global.Ring100Check_Deactivate = false;         
             
          // Update Camera position:
             obj_camera.x      = x;
             obj_camera.y      = y;     
             obj_camera.Cam_XX = x;
             obj_camera.Cam_XX = y;                              
       }
    }

</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Vars

//Mighty's hammer drop
            stomping=false;
    stomp_bouncing=false;
    // Boosting //
    boosting            = false;        // Flag for when the player is boosting.
    boosting_power      = 100;          // How long the player can boost.    
    allow_boosting=true;
    slidingtimer=0;
airdashing = false;
platform_swing = 0;
dropdash= false;

///Robotnik Dash
 can_dash=true;
    dashspd=12.5;
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>604</id>
        <kind>0</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>0</useapplyto>
        <exetype>1</exetype>
        <functionname>action_inherited</functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
      </action>
    </event>
    <event eventtype="2" enumb="1">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Destroy shields underwater.
    if(Shield = ShieldElectricity &amp;&amp; !instance_exists(obj_effect_electro_flash)){
       instance_create(0, 0, obj_effect_electro_flash);
    }         
    Shield = ShieldDefault;
    with(ShieldChild){
         instance_destroy();
    }
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Decrease Rings.
    global.Rings--
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="2">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Keep the character within the level's boundaries.

   // Create the Sprite offset:
      var _SOffset = sprite_get_width(spr_mask_main) div 2;
      
   // Find Camera:    
      var _Cam     = obj_camera;
                    
   // Check the Horizontal speed and whether not we collide with the horizontal borders:
      if(instance_exists(_Cam)){
         if(x &lt;= (_Cam.Cam_LeftLimit)+_SOffset &amp;&amp; XSpeed &lt; 0.0){  
            XSpeed = 0;
            x     = (_Cam.Cam_LeftLimit)+_SOffset;
         }else
         if(x &gt;= (_Cam.Cam_RightLimit)-_SOffset &amp;&amp; XSpeed &gt; 0.0){   
            XSpeed = 0;
            x      = (_Cam.Cam_RightLimit)-_SOffset
         }                       
      }

   
    // Keep the character within the camera's boundaries.
       var _C;
       _C = instance_nearest(x, y, obj_camera);       
      /* 
       if(_C != noone){
          if(_C.Camera_BindX == 1){
             if(x &lt;= _C.Camera_MinX - 7 + _SOffset &amp;&amp; XSpeed &lt; 0.0){
                XSpeed = 0;
                x      = _C.Camera_MinX - 7  + _SOffset; 
             }else
             if(x &gt;= _C.Camera_MaxX - 7  - _SOffset &amp;&amp; XSpeed &gt; 0.0){
                XSpeed = 0;
                x      = _C.Camera_MaxX - 7  - _SOffset; 
             }             
          }
          if(_C.Camera_BindY == 1){
             if(y &lt;= _C.Camera_MinY + _SOffset*2 &amp;&amp; YSpeed &lt; 0.0){
                YSpeed = 0;
                y      = _C.Camera_MinY + _SOffset*2; 
             }      
          }          
       }
       */
/*         if(_C != noone){
          if(_C.Camera_BindX == 1){
             if(x &lt;= view_xview - 7 + _SOffset &amp;&amp; XSpeed &lt; 0.0){
                XSpeed = 0;
                x      = view_xview - 7 + _SOffset;
             }
             if(x &gt;= view_xview+320 + 7 - _SOffset &amp;&amp; XSpeed &gt; 0.0){
                XSpeed = 0;
                x      = view_xview+320 + 7 - _SOffset;
             }             
          }
       }

</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Animation Core.
// Define the core system of the animation system:
   scr_animation_core();
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Apply Animations and Direction.
// Used to apply animations and change the facing direction:

   // Change the direction we face:
      scr_animation_direction();
      
   // Apply the correct animation:
      scr_animation_apply();   
      scr_animation_apply_tail();
 
// In some cases we have to modify the animation speed, and we do exactly that here:

   // Walking/Jogging Animation:
      if(Animation == "WALK" &amp;&amp; Ground){
        if(CharacterID == CharacterSonic){
           AnimationSpeed = min(0.30, max(0.05+abs(XSpeed)/25));
        }
        if(CharacterID == CharacterTails){
           AnimationSpeed = min(0.25, max(0.10+abs(XSpeed)/25));
           TailSpeed      = min(0.20, max(0.10+abs(XSpeed)/25));
      }
        if(CharacterID == CharacterKnuckles){
           AnimationSpeed = min(0.25, max(0.05+abs(XSpeed)/25));
        }      
        if(CharacterID == CharacterAmy){
           AnimationSpeed = min(0.20, max(0.05+abs(XSpeed)/25));
           
        if(CharacterID == CharacterShadow){
           AnimationSpeed = min(0.30, max(0.05+abs(XSpeed)/25));
        } 
        if(CharacterID == CharacterMetal){
           AnimationSpeed = min(0.30, max(0.05+abs(XSpeed)/25));
        }
        if(CharacterID == CharacterModern){
           AnimationSpeed = min(0.30, max(0.05+abs(XSpeed)/25));
        }
        if(CharacterID == CharacterMighty){
           AnimationSpeed = min(0.30, max(0.05+abs(XSpeed)/25));
        }
     }
   }
   // Running Animation:
      if(Ground &amp;&amp; Animation == "RUN"){
         if(CharacterID == CharacterSonic &amp;&amp; CharacterState != CharacterNormal){
            AnimationSpeed = 0.20;
         }else{
            AnimationSpeed = 0.20+abs(XSpeed)/25;
         }
         if(CharacterID == CharacterTails){
            AnimationSpeed = 0.20+abs(XSpeed)/25;
            TailSpeed      = 0.25+abs(XSpeed)/25;
         }
         if(CharacterID == CharacterKnuckles){
            AnimationSpeed = 0.20+abs(XSpeed)/25;
         }         
         if(CharacterID == CharacterAmy){
            if(Action != ActionSpindash){
               AnimationSpeed = 0.10+abs(XSpeed)/20;
            }else{
               AnimationSpeed = (SpindashAccumulator)*.030;
            }
         }
         if(CharacterID == CharacterShadow){
            AnimationSpeed = 0.20;
         } 
         if(CharacterID == CharacterModern){
         AnimationSpeed = 0.20;
         }
         if(CharacterID == CharacterMighty){
         AnimationSpeed = 0.20;
         }
         if(CharacterID == CharacterMetal){
         AnimationSpeed = 0.20;
         }
         }

   // Rolling Animation:  
      if(Action = ActionRolling){
        if(CharacterID != CharacterTails){
           if(Ground == true){
              AnimationSpeed = 0.25+abs(XSpeed)/12;
              RenderingSpeed = AnimationSpeed;
           }else{
              AnimationSpeed = RenderingSpeed;
          }
        }else{
            AnimationSpeed = 0.25;
            TailSpeed      = 0.25;
        }
      }
  
   // Jumping Animation:
      if(Action = ActionJump &amp;&amp; CharacterID != CharacterAmy){
         if(CharacterID != CharacterAmy){
            if(CharacterID != CharacterTails){
               if(DropDashFlag != 2){
                  // We set the rendering speed in the jump script.
                     AnimationSpeed = RenderingSpeed;
               }
            }else{
               AnimationSpeed = 0.25;
               TailSpeed      = 0.25;
            }
         }
      }  
  
   // Amy's Jumping/Rolling Animation: 
      if(CharacterID == CharacterAmy){
         if(Action == ActionJump &amp;&amp; AmyRollJump == false || Animation == "JUMP"){
            if(YSpeed &gt; 0 &amp;&amp; AnimationFrame &lt; 2){
               AnimationFrame += 0.25;
            }else if(YSpeed &gt; 0 &amp;&amp; AnimationFrame &gt;= 2){
                     AnimationFrame = 2;
            }
            if(YSpeed &lt;= 0){
               AnimationFrame = 0;
            }
         }else if(Action == ActionJump &amp;&amp; AmyRollJump == true){
                  AnimationSpeed = RenderingSpeed;
         }
      }  
  
   // Amy's Hammer Spin Animation:  
      if(CharacterID == CharacterAmy){
         if(AmyHammerAttack == 2){
            AnimationSpeed = min(0.30, max(0.10+abs(XSpeed)/25));
         }
      }
  
   // Limit Jump/Roll Animation:
      if(Action == ActionJump || Action == ActionRolling){
         if(RenderingSpeed &gt; 1.5){
            RenderingSpeed = 1.5;
         }
         if(AnimationSpeed &gt; 1.5){
            AnimationSpeed = 1.5
         }
      }
  
   // If we hit a wall, reset the animation speed while jumping.
      if(!Ground &amp;&amp; YSpeed &gt;= 0 &amp;&amp; (scr_character_collision_right(x, y, 0, spr_mask_big) &amp;&amp; KeyRight || scr_character_collision_left(x, y, 0, spr_mask_big) &amp;&amp; KeyLeft )){
         if(Action = ActionJump || Action = ActionRolling){
            RenderingSpeed = 0.25;
            AnimationSpeed = 0.25;
         }
      }
      
           
   // In some cases, we have to modify the animation speed, we do exactly that, here:
/*   
      // Modify the Walking/Jogging animation:
      if(Animation == "WALK" &amp;&amp; Ground){
         if(CharacterID == CharacterSonic){
            AnimationSpeed = min(0.30, max(0.05+abs(XSpeed)/25));
         }
         if(CharacterID == CharacterAmy){
            AnimationSpeed = min(0.20, max(0.05+abs(XSpeed)/25));        
         }
         if(CharacterID == CharacterTails){
            AnimationSpeed = 0
            TailSpeed      = min(0.025, max(0.05+abs(XSpeed)/25));            
         }        
      }
   
      // Modify the Running animation:
      if(Ground){
         if(Animation == "RUN"){
            if(CharacterID != CharacterAmy){            
               if((CharacterState != CharacterSuper &amp;&amp; CharacterState != CharacterHyper)){
                  AnimationSpeed = 0.20+abs(XSpeed)/25
               }else{
                  AnimationSpeed = 0.20; // Super Sonic "Flying" Frame speed.
               }
               TailSpeed = 0.25+abs(XSpeed)/25;
            }else{
               if(Action != ActionSpindash){
                  AnimationSpeed = 0.10+abs(XSpeed)/20;
               }else{
                  AnimationSpeed = (SpindashAccumulator)*.030
               } 
            }
         }
      }
         
      // Modify the Rolling animation:    
         if(CharacterID != CharacterTails){
            if(Action = ActionRolling &amp;&amp; Ground){
               AnimationSpeed = 0.25+abs(XSpeed)/12;
               RenderingSpeed = AnimationSpeed;
            }else
            if(Action = ActionRolling &amp;&amp; !Ground){
               AnimationSpeed = RenderingSpeed;         
            }
         }else{
               AnimationSpeed = 0.25
         }               
      
         
      // Modify the Jumping animation:
      if(CharacterID != CharacterAmy){
         if(CharacterID != CharacterTails){      
            if(Action = ActionJump &amp;&amp; DropDashFlag != 2){
               // We set the rendering speed that we use here
               // in scr_character_action_jump()
               AnimationSpeed = RenderingSpeed;         
            }
         }else{
               AnimationSpeed = 0.25;
         }
      }
      
      // Amy Jump/Roll Animation:
      if(CharacterID = CharacterAmy){
         if(Action = ActionJump &amp;&amp; AmyRollJump = false || Animation = "JUMP"){
            if(YSpeed &gt; 0 &amp;&amp; AnimationFrame &lt; 2){
               AnimationFrame += 0.25;
            }else if(YSpeed &gt; 0 &amp;&amp; AnimationFrame &gt;= 2 ){
                     AnimationFrame = 2;
            }
            if(YSpeed &lt;= 0){
               AnimationFrame = 0;
            }           
         }else if(Action = ActionJump &amp;&amp; AmyRollJump = true){
                  AnimationSpeed = RenderingSpeed; 
         }           
      }      
      
      // Amy hammer spin:
      if(CharacterID == CharacterAmy){
         if(AmyHammerAttack = 2){
            AnimationSpeed = min(0.30, max(0.10+abs(XSpeed)/25));
         }
      }
      
      // Limit the Jumping/Rolling animation speed:
         if(Action = ActionJump || Action = ActionRolling){
            if(RenderingSpeed &gt; 1.5){
               RenderingSpeed = 1.5;
            }
            if(AnimationSpeed &gt; 1.5){
               AnimationSpeed = 1.5;
            }            
         }
      
      // If we hit a wall while Jumping OR rolling, reset the animation speed just like in original games: 
      if(!Ground &amp;&amp; YSpeed &gt;= 0 &amp;&amp; (scr_character_collision_right(x, y, 0, spr_mask_big) &amp;&amp; KeyRight || scr_character_collision_left(x, y, 0, spr_mask_big) &amp;&amp; KeyLeft )){
         if(Action = ActionJump || Action = ActionRolling){
            RenderingSpeed = 0.25;
            AnimationSpeed = 0.25;
         }
      }
      
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Rotate the characters sprite.
// This will rotate the sprite while resolve thikering when moving on slopes.
   
   // Only run this if we're using the 360 rotation.
      if(global.AngleMode == 360){
         if(!scr_character_collision_bottom_object(x,y, Angle, spr_mask_main, par_collision_solid_no_angle) &amp;&amp; !scr_character_collision_bottom_object(x, y, Angle, spr_mask_main, par_collision_platform_no_angle)){
            if(Ground &amp;&amp; (AnimationDirection == 1 &amp;&amp; Angle &gt;= 45 &amp;&amp; Angle &lt;= 300) or (AnimationDirection == -1 &amp;&amp; Angle &gt;= 45 &amp;&amp; Angle &lt;= 310)){            
               AnimationAngle = RelativeAngle; 
               TailAngle      = Angle;
            }else{
               AnimationAngle = scr_character_rotate_towards(0, AnimationAngle, 6);
               TailAngle      = scr_character_rotate_towards(0, TailAngle, 6);  
            }
         }else{
               AnimationAngle = 0;
               TailAngle      = 0;         
         }
       }
          
   // Otherwise, only use 8 directions for the rotation:
      if(global.AngleMode == 8){ 
         if(Ground &amp;&amp; !scr_character_collision_bottom_object(x,y, Angle, spr_mask_main, par_collision_solid_no_angle) &amp;&amp; !scr_character_collision_bottom_object(x, y, Angle, spr_mask_main, par_collision_platform_no_angle)){    
            if(Angle&gt;=328   &amp;&amp; Angle&lt;   360) { AnimationAngle =   0; TailAngle =   0; }
            if(Angle&gt;=0     &amp;&amp; Angle&lt;    45) { AnimationAngle =   0; TailAngle =   0; }
            if(Angle&gt;=45    &amp;&amp; Angle&lt;  67.5) { AnimationAngle =  45; TailAngle =  45; }
            if(Angle&gt;=67.5  &amp;&amp; Angle&lt; 112.5) { AnimationAngle =  90; TailAngle =  90; }
            if(Angle&gt;=112.5 &amp;&amp; Angle&lt; 157.5) { AnimationAngle = 135; TailAngle = 135; }
            if(Angle&gt;=157.5 &amp;&amp; Angle&lt; 202.5) { AnimationAngle = 180; TailAngle = 180; }
            if(Angle&gt;=202.5 &amp;&amp; Angle&lt; 247.5) { AnimationAngle = 225; TailAngle = 225; }
            if(Angle&gt;=247.5 &amp;&amp; Angle&lt; 292.5) { AnimationAngle = 270; TailAngle = 270; }
            if(Angle&gt;=292.5 &amp;&amp; Angle&lt;   328) { AnimationAngle = 315; TailAngle = 315; } 
            SnapTimer = 8;
         }else{
            if(--SnapTimer &lt;= 0){
               AnimationAngle = scr_character_rotate_towards(0, AnimationAngle, 45);
               TailAngle      = scr_character_rotate_towards(0, TailAngle, 45);         
               SnapTimer      = 8;
            }
         }              
      }
        
   // Set the Angle to 0 at certain animations:
      if(Animation = "IDLE" || Animation = "IDLE_2" || Animation = "LOOK_UP"       || Animation = "CROUCH"         || Animation = "SPINDASH" || 
         Animation = "ROLL" || Animation = "HURT"   || Animation = "GOAL"          || Animation = "EDGE_BALANCE_1" || Animation = "EDGE_BALANCE_2" ||
         Animation = "PUSH" || Animation = "FLY"    || Animation = "FLY_EXHAUSTED" || Rotation_Animation != 0){  
           
         AnimationAngle = 0;
         if(Animation  != "ROLL"){
            TailAngle   = 0;
         }
         
      }

   // Set the Angle of Miles tail.
      if((Action = ActionJump || Action = ActionRolling || Animation = "ROLL") &amp;&amp; Ground == false){
          TailAngle     = point_direction(xprevious, yprevious, x, y);
          if(Ground == false &amp;&amp; TailDirection != 1){
             TailDirection = 1;
          }
      }
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Water Splash effect.

 // Create a Water Splash:
    if(global.WaterSurfacePosition != -1 &amp;&amp; Action != ActionDie){
       if ((abs(YSpeed) &gt;= 0)
       &amp;&amp; ((y &gt; global.WaterSurfacePosition &amp;&amp; PreviousY &lt; global.WaterSurfacePosition)
       ^^  (y &lt; global.WaterSurfacePosition &amp;&amp; PreviousY &gt; global.WaterSurfacePosition))){
           scr_create_dummy_effect(spr_water_splash, 0.25, x, global.WaterSurfacePosition-8, 1, -999996);
           PlaySound(snd_object_water_splash, global.SFXVolume, 1, 1);
       }
    }

</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Platform Check Reset.
 // To prevent that the character bounces or loses collision on platforms, we create a 30 frames long timer.

   if((Ground == false || place_meeting(x, y, par_collision_platform) == false) &amp;&amp; PlatformCheck == 1){
      if(PlatformCheckTimer &gt; 0){
         PlatformCheckTimer -= 1;
      }else if(PlatformCheckTimer = 0){
               PlatformCheck      = false;
               PlatformCheckTimer = 30;
      }
   }
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="1">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Get the input keys.
// If you want to modify any of this. Do so in scr_game_init()

          if(LockControl == 0) &amp;&amp; !gms_chat_istyping(){
        
             // Keys:
                KeyUp               = keyboard_check(global.Key_UP)     || (gamepad_axis_value(0, gp_axislv) &lt;  0) || (gamepad_axis_value(4, gp_axislv) &lt;  0);
                KeyDown             = keyboard_check(global.Key_DOWN)   || (gamepad_axis_value(0, gp_axislv) &gt;  0) || (gamepad_axis_value(4, gp_axislv) &gt;  0);
                KeyRight            = keyboard_check(global.Key_RIGHT)  || (gamepad_axis_value(0, gp_axislh) &gt;  0) || (gamepad_axis_value(4, gp_axislh) &gt;  0);
                KeyLeft             = keyboard_check(global.Key_LEFT)   || (gamepad_axis_value(0, gp_axislh) &lt;  0) || (gamepad_axis_value(4, gp_axislh) &lt;  0);
                KeyAction           = keyboard_check(global.Key_ACTION);
                KeySpecial          = keyboard_check(global.Key_SPECIAL);
                KeyEnter            = keyboard_check(global.Key_ENTER);
       
             // Key presses:
                KeyUp_Pressed       = keyboard_check_pressed(global.Key_UP);
                KeyDown_Pressed     = keyboard_check_pressed(global.Key_DOWN);
                KeyRight_Pressed    = keyboard_check_pressed(global.Key_RIGHT);
                KeyLeft_Pressed     = keyboard_check_pressed(global.Key_LEFT);
                KeyAction_Pressed   = keyboard_check_pressed(global.Key_ACTION);
                KeySpecial_Pressed  = keyboard_check_pressed(global.Key_SPECIAL);
                KeyEnter_Pressed    = keyboard_check_pressed(global.Key_ENTER);      
       
             // Key releases:
                KeyUp_Released      = keyboard_check_released(global.Key_UP);
                KeyDown_Released    = keyboard_check_released(global.Key_DOWN);
                KeyRight_Released   = keyboard_check_released(global.Key_RIGHT);
                KeyLeft_Released    = keyboard_check_released(global.Key_LEFT);
                KeyAction_Released  = keyboard_check_released(global.Key_ACTION);
                KeySpecial_Released = keyboard_check_released(global.Key_SPECIAL);
                KeyEnter_Released   = keyboard_check_released(global.Key_ENTER);             
       
             // Stop left &amp; right at the same time:
                if(KeyRight &amp;&amp; KeyLeft){
                   KeyRight = false;
                   KeyLeft  = false;
                }    
             
             // Input Alarm:
                if(InputAlarm){
                   if(AlarmDirection = 1){
                      KeyRight = false
                   }
                   if(AlarmDirection = -1){
                      KeyLeft  = false
                   }                
                }   

             // Input Lock:
                if(InputLock_L){
                   KeyLeft = false;
                }
                if(InputLock_R){
                   KeyRight = false;
                }      
       
             // Holding Jump:
                if(KeyAction){
                   if(global.Key_ACTION_HeldTimer != 10){
                      global.Key_ACTION_HeldTimer++
                   }
                }else{
                   global.Key_ACTION_HeldTimer = 0;
                }
          }
          
          if LockControl==1 or gms_chat_istyping() {scr_input()}
       

</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Modify Physics.

 // Previous Positions:
    PreviousX = x;
    PreviousY = y;
          
 // Switch Physic Modes:
    if(y &lt; global.WaterSurfacePosition or instance_exists(obj_water) == false){
       if(PhysicMode != "Normal"){
          PhysicMode  = "Normal";
          Underwater  = false;
       }
    } 
    if(y &gt; global.WaterSurfacePosition &amp;&amp; instance_exists(obj_water) == true){
       if(PhysicMode != "Underwater"){
          PhysicMode  = "Underwater";  
          Underwater  = true;                     
       }       
    }

 // Sonic and Tails Physics:
    if(CharacterID != CharacterAmy &amp;&amp; CharacterState = CharacterNormal){
    
       if(PhysicMode == "Normal"){
       
          // Horizontal Values:
             if(HasSpeedShoes == false){
                XSpeed_Top    = 6;
             }else{
                XSpeed_Top    = 12;
             }
             
             XSpeed_Max     = 16;
             
             if(HasSpeedShoes == false){
                XAcceleration = 0.046875;
             }else{
                XAcceleration = 0.09375;
             }
             
             XDeceleration  = 0.5;              
             XSlopeFactor   = 0.5;
             
             if(HasSpeedShoes == false){
                AirAccel      = 0.09375;
             }else{
                AirAccel      = 0.1875;
             }             
             
           
          // Vertical Values:          
             YSpeed_Max     = 16;      
             if(Action != ActionGlide &amp;&amp; Action != ActionClimb){
                if(Action != ActionFly &amp;&amp; Action != ActionFlydrop){
                   if(Action = ActionHurt){
                      YAcceleration = 0.1875;
                   }else{
                      YAcceleration = YAccel_Common;
                   }
                }
             }else{
               YAcceleration = 0;
             }
             ConversionFact = 0.8;
             
          // Jumping Values:
             if(CharacterID != CharacterKnuckles){
                JumpStrength = -6.5;
             }else{
                JumpStrength = -6;
             }
             JumpRelease    = -4;
             
          // Rolling Values:   
             RollDec                   = 0.3;      
             
             if(HasSpeedShoes == false){
                RollDecLight  = 0.0234375; 
             }else{
                RollDecLight  = 0.046875;
             }
             
             
             RollDecStrong             = 0.125;   
             Rolling_Deceleration_Up   = 0.078125; 
             Rolling_Deceleration_Down = 0.3125;        
      
          // Spindash:
             SpindashAccumMax    =  12;  
             SpindashAccumMin    =  8;                         
                             
       }
       
       if(PhysicMode == "Underwater"){
        
          // Horizontal Values:
             XSpeed_Top     = 3;
             XSpeed_Max     = 16;
             XAcceleration  = 0.0234375;
             XDeceleration  = 0.5;                 
             XSlopeFactor   = 0.25;
             AirAccel       = 0.09375*0.5;
             
          // Vertical Values:          
             YSpeed_Max     = 16; 
             if(Action != ActionGlide &amp;&amp; Action != ActionClimb){
                if(Action != ActionFly &amp;&amp; Action != ActionFlydrop){             
                   if(Action = ActionHurt){
                      YAcceleration = 0.1875*0.5;
                   }else{
                      YAcceleration = 0.0625;
                   }     
                }       
             }else{
               YAcceleration = 0;
             }
             ConversionFact = 0.8;
             
          // Jumping Values:
             if(CharacterID != CharacterKnuckles){
                JumpStrength = -3.5;
             }else{
                JumpStrength = -3;
             }
             JumpRelease    = -2;
             
             
             
          // Rolling Values:   
             RollDec                   = 0.3;       
             RollDecLight              = 0.0234375; 
             RollDecStrong             = 0.125;   
             Rolling_Deceleration_Up   = 0.078125; 
             Rolling_Deceleration_Down = 0.3125;        
      
          // Spindash:
             SpindashAccumMax    =  12;  
             SpindashAccumMin    =  8;                         
                                                                                              
       }      
        
    }
    if((CharacterID == CharacterSonic || CharacterID == CharacterTails || CharacterID == CharacterKnuckles || CharacterID = CharacterShadow || CharacterID = CharacterMighty || CharacterID = CharacterMetal || CharacterID = CharacterModern) &amp;&amp; (CharacterState = CharacterSuper or CharacterState = CharacterHyper)){
    
       if(PhysicMode == "Normal"){
       
          // Horizontal Values:
             XSpeed_Top     = 10;
             XSpeed_Max     = 16;
             XAcceleration  = 0.046875*4;
             XDeceleration  = 1;                 
             XSlopeFactor   = 0.5*2;
             AirAccel       = 0.09375*4;
             
          // Vertical Values:          
             YSpeed_Max     = 16; 
             if(Action != ActionGlide &amp;&amp; Action != ActionClimb){             
                if(Action != ActionFly &amp;&amp; Action != ActionFlydrop){
                   if(Action = ActionHurt){
                      YAcceleration = 0.1875;
                   }else{
                      YAcceleration = YAccel_Common;
                   }
                }
             }else{
               YAcceleration = 0;
             }
             ConversionFact = 0.8;
             
          // Jumping Values:
             if(CharacterID == CharacterSonic || CharacterID = CharacterShadow || CharacterID = CharacterMighty || CharacterID = CharacterMetal || CharacterID = CharacterModern){
                JumpStrength = -8;
             }
             if(CharacterID == CharacterTails){
                JumpStrength = -6.5;
             }             
             if(CharacterID == CharacterKnuckles){
                JumpStrength = -6
             }
             JumpRelease    = -4;
             
          // Rolling Values:   
             RollDec                   = 0.3;       
             RollDecLight              = 0.0234375; 
             RollDecStrong             = 0.125;   
             Rolling_Deceleration_Up   = 0.078125; 
             Rolling_Deceleration_Down = 0.3125;        
      
          // Spindash:
             SpindashAccumMax    =  15;  
             SpindashAccumMin    =  11;                       
                                                                                                           
       }
       
       if(PhysicMode == "Underwater"){
       
          // Horizontal Values:
             XSpeed_Top     = 5;
             XSpeed_Max     = 16;
             XAcceleration  = 0.0234375*4;
             XDeceleration  = 0.25;
             XSlopeFactor   = 0.25*2;
             AirAccel       = 0.09375*0.5;
             
          // Vertical Values:          
             YSpeed_Max     = 16; 
             if(Action != ActionGlide &amp;&amp; Action != ActionClimb){                
                if(Action != ActionFly &amp;&amp; Action != ActionFlydrop){
                   if(Action = ActionHurt){
                      YAcceleration = 0.1870*0.5;
                   }else{
                      YAcceleration = 0.046875;
                   }
                }
             }else{
               YAcceleration = 0;
             }                       
             ConversionFact = 0.8;
             
          // Jumping Values:
             if(CharacterID == CharacterSonic || CharacterID == CharacterTails || CharacterID = CharacterShadow || CharacterID = CharacterMighty || CharacterID = CharacterMetal || CharacterID = CharacterModern){
                JumpStrength = -3.5;
             }            
             if(CharacterID == CharacterKnuckles){
                JumpStrength = -3
             }          
             JumpRelease    = -2;
             
          // Rolling Values:   
             RollDec                   = 0.3;       
             RollDecLight              = 0.0234375; 
             RollDecStrong             = 0.125;   
             Rolling_Deceleration_Up   = 0.078125; 
             Rolling_Deceleration_Down = 0.3125;        
      
          // Spindash:
             SpindashAccumMax    =  15;  
             SpindashAccumMin    =  11;                     
                                                                                              
       }      
        
    }   
    
 // Amy Rose Physics:
    if((CharacterID == CharacterAmy) &amp;&amp; CharacterState = CharacterNormal){
    
       if(PhysicMode == "Normal"){
       
          // Horizontal Values:
             if(HasSpeedShoes == false){
                XSpeed_Top    = 5.8;
             }else{
                XSpeed_Top    = 11.8;
             }
             
             XSpeed_Max     = 13.25;
             
             if(HasSpeedShoes == false){
                XAcceleration = 0.046875;
             }else{
                XAcceleration = 0.09375;
             }
             
             XDeceleration  = 0.5;              
             XSlopeFactor   = 0.5;
             
             if(HasSpeedShoes == false){
                AirAccel      = 0.09375;
             }else{
                AirAccel      = 0.1875;
             }             
             
           
          // Vertical Values:          
             YSpeed_Max     = 16; 
             
             if(Action != ActionFly &amp;&amp; Action != ActionFlydrop){
                if(Action = ActionHurt){
                   YAcceleration = 0.1875;
                }else{
                   YAcceleration = YAccel_Common;
                }
             }
             ConversionFact = 0.8;
             
          // Jumping Values:
             JumpStrength   = -6.5;
             JumpRelease    = -4;
             
          // Rolling Values:   
             RollDec = 0.3;      
             
             if(HasSpeedShoes == false){
                RollDecLight  = 0.0234375; 
             }else{
                RollDecLight  = 0.046875;
             }
                          
             RollDecStrong             = 0.125;   
             Rolling_Deceleration_Up   = 0.078125; 
             Rolling_Deceleration_Down = 0.3125;        
      
          // Spindash:
             SpindashAccumMax    =  10;  
             SpindashAccumMin    =  6;                         
                             
       }
       
       if(PhysicMode == "Underwater"){
        
          // Horizontal Values:
             XSpeed_Top     = 2.8;
             XSpeed_Max     = 13.25;
             XAcceleration  = 0.0234375;
             XDeceleration  = 0.5;                 
             XSlopeFactor   = 0.25;
             AirAccel       = 0.09375*0.5;
             
          // Vertical Values:          
             YSpeed_Max     = 16; 
             if(Action != ActionFly &amp;&amp; Action != ActionFlydrop){             
                if(Action = ActionHurt){
                   YAcceleration = 0.1875*0.5;
                }else{
                   YAcceleration = 0.0625;
                }     
             }       
             ConversionFact = 0.8;
             
          // Jumping Values:
             JumpStrength   = -3.5;
             JumpRelease    = -2;
             
          // Rolling Values:   
             RollDec                   = 0.3;       
             RollDecLight              = 0.0234375; 
             RollDecStrong             = 0.125;   
             Rolling_Deceleration_Up   = 0.078125; 
             Rolling_Deceleration_Down = 0.3125;        
      
          // Spindash:
             SpindashAccumMax    =  10;  
             SpindashAccumMin    =  6;                         
                                                                                              
       }      
        
    }     

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Death.
    if(Action = ActionDie){
    
       if(DeathTimer == "NO"){
          Angle = 0;
          if(global.BonusStage == false &amp;&amp; Underwater == false){            
             YSpeed        = -7;
          }          
          DeathTimer    = 120;
          depth         = -999995;  
          if(instance_exists(obj_audio_manager)){
             with(obj_audio_manager){
                  DeadFade = true;
             }
          }       
          if(global.BonusStage == false){          
             global.Lives -= 1;
             global.DoTime = 0;
             PlaySound(snd_character_die, global.SFXVolume, 1, 0);
          }
          
          // Destroy Shields:
             if(ShieldChild != 0){
                with(ShieldChild){
                     instance_destroy();
                }
             }             
             
          // Make sure to reset the Character state:
             CharacterState = CharacterNormal;
             Animation      = "IDLE";
             alarm[0]       = -1;             
             
       }
       
       // Set Gravity:
          if(Underwater == false){
             YSpeed += 0.21875;
          }else{
             YSpeed += 0.0625;
          }
          y      += YSpeed;
          
       
       // Stop Sounds:
          StopSound(snd_character_flying);
          StopSound(snd_character_flying_fall);
          
       // Decrease Kill Timer:
          if(DeathTimer != 0){
             DeathTimer--
          }
          if(DeathTimer &gt; -128 &amp;&amp; DeathTimer &lt;= 0){
             if(global.BonusStage == false){
                if(global.Lives &gt; 0){
                   if(instance_exists(obj_fade_restart) == false){
                      instance_create(0, 0, obj_fade_restart);
                   }
                }else{
                   if(instance_exists(obj_game_over) == false){
                      instance_create(0, 0, obj_game_over);
                   }                
                }
             }else{
                   if(instance_exists(obj_fade_from_bonus) == false){
                      instance_create(0, 0, obj_fade_from_bonus);                   
                   }               
             }
             DeathTimer = -128;
          } 
       
    }
    
 // Death fade fix:
    if(instance_exists(obj_audio_manager)){
       if(obj_audio_manager.DeadFade == true &amp;&amp; Action != ActionDie){
          DeadFade = -1;
       }
    }

    
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Handle X/Y, Collision and Objects.


 // Exit if we're death:
    if(Action != ActionDie){
                                                                             
    var TotalSteps, Sample;

    if(Allow_XMovement) {
       if(SpeedLimit){
          XSpeed = scr_clamp(XSpeed, -XSpeed_Max, XSpeed_Max);
       }

    TotalSteps = 1;
    if(XSample &gt; 0) {
       TotalSteps += floor(abs(XSpeed) / XSample);
    }

    Sample = XSpeed / TotalSteps;

    repeat (TotalSteps) {
                                             
        x += cos(degtorad(Angle)) * Sample;               
        y -= sin(degtorad(Angle)) * Sample;
           
        // Move the Character outside in case he gets stuck inside a wall:
        while (Sample &gt; 0 &amp;&amp; scr_character_collision_right(x, y, Angle, spr_mask_mid) == true) {
               x -= cos(degtorad(Angle));
               y += sin(degtorad(Angle));          
        }
        while (Sample &lt; 0 &amp;&amp; scr_character_collision_left(x, y, Angle, spr_mask_mid) == true) {
               x += cos(degtorad(Angle));
               y -= sin(degtorad(Angle));         
        }
         
       scr_player_handle()
        
        if (Ground) {
            while (scr_character_collision_main(x, y)) {
                x -= sin(degtorad(Angle));
                y -= cos(degtorad(Angle));
            }
            if (scr_character_collision_slopes(x, y, Angle, spr_mask_mid)) {
                while (not scr_character_collision_main(x, y)) {
                    x += sin(degtorad(Angle));
                    y += cos(degtorad(Angle));
                }
            }
              
            if (Allow_YMovement) {

                // Get a new angle:
                if (scr_character_collision_left_edge(x, y, Angle) and scr_character_collision_right_edge(x, y, Angle)) {
                    Angle = scr_character_calculate_angle(x, y, Angle);
                }
            }
        }
        
        scr_character_handle_tunnel_locks();          
        scr_character_handle_collectibles();       
        scr_character_handle_harmful();
        scr_character_handle_spikes();         
        scr_character_handle_obstacles();                                               
        scr_character_handle_monitors("Side");      
        scr_character_handle_enemies();  
        scr_character_handle_misc()                
        if (XSpeed == 0) {
            break; // abort;
        }
               
    }
            
}     
                
if (Allow_YMovement) {   
    // Limit the vertical speed:
    if (AirLimit) {
        YSpeed = scr_clamp(YSpeed, -YSpeed_Max, YSpeed_Max);
    }

    if (not Ground) {
        TotalSteps = 1;
        if (XSample &gt; 0) {
            TotalSteps += floor(abs(YSpeed) / YSample);
        }
    
        Sample = YSpeed / TotalSteps;
    
        repeat (TotalSteps) {
                                                 
            x += sin(degtorad(Angle)) * Sample;
            y += cos(degtorad(Angle)) * Sample;

            // Move the player outside in case he got stuck inside floor or the ceiling:        
            while (Sample &lt; 0 and scr_character_collision_top(x, y, 0, spr_mask_mid) == true) {
                   x += sin(degtorad(Angle));
                   y += cos(degtorad(Angle));
            }
            while (Sample &gt; 0 and scr_character_collision_bottom(x, y, 0, spr_mask_mid) == true) {
                   x -= sin(degtorad(Angle));            
                   y -= cos(degtorad(Angle));           
            }
  
            scr_character_handle_launch_sensor();                        
            scr_character_handle_layers();
            scr_character_handle_tunnel_locks();            
            scr_character_handle_watersurface()
            scr_character_handle_collapsing_tiles();
            scr_character_handle_springs();
            scr_character_handle_casino_gimmicks();   
            scr_character_handle_bosses();                     
            scr_character_handle_platforms();
            scr_character_handle_enemies()        
            scr_character_handle_monitors("Top");            
            scr_character_handle_bonus_objects();                      
                                  
            // Check for Landing:            
            if (YSpeed &gt;= 0 and scr_character_collision_bottom(x, y, 0, spr_mask_big)) {
                 if (scr_character_collision_left_edge(x, y, 0) and scr_character_collision_right_edge(x, y, 0)) {
                    scr_character_angle(scr_character_calculate_angle(x, y, Angle));
                 } else {
                    scr_character_angle(global.GravityAngle);
                 }
                 
                 // Check if landed on obstacles
                 if (scr_character_collision_bottom_object(x, y, Angle, spr_mask_main, par_collision_obstacles)) {
                     scr_character_angle(global.GravityAngle);
                 }

                 if(abs(XSpeed) &lt;= abs(YSpeed) &amp;&amp; RelativeAngle &gt;= 22.5 &amp;&amp; RelativeAngle &lt;= 337.5){
                    XSpeed = -YSpeed*sign(sin(degtorad(RelativeAngle)));
                    if(RelativeAngle &lt; 45 || RelativeAngle &gt; 315) { XSpeed *= 0.5 }
                 }
  
                 //XSpeed -= sin(degtorad(Angle))*(YSpeed+ConversionFact);
                 YSpeed = 0;
                 Ground = true;
                                               
                 // Return to a normal state when the character was hurt or jumping:
                 if (Action = ActionHurt || Action = ActionJump){
                     Action = ActionNormal;    
                 }
              
                 // Return to a normal state when the character was flying:
                 if (Action = ActionFly || Action = ActionFlydrop) {
                     Action = ActionNormal;
                     YAcceleration = YAccel_Common;
                 }
            }
            
            if ((YSpeed &lt; 0 and scr_character_collision_top(x, y, 0, spr_mask_large)) &amp;&amp; (!scr_character_collision_top_object(x, y, Angle, spr_mask_large, par_collision_obstacles))) {
            
                // Calculate new terrain angle
                scr_character_angle(180);
             
                // Check if possible to land using that angle
                if (scr_character_collision_left_edge(x, y, Angle) &amp;&amp; scr_character_collision_right_edge(x, y, Angle)) {
                    scr_character_angle(scr_character_calculate_angle(x, y, Angle));

                                                                 
                    // Check if the landed angle isn't a flat top
                    if (RelativeAngle &gt; 160 &amp;&amp; RelativeAngle &lt; 200) {
                        scr_character_angle(global.GravityAngle);
                        YSpeed       = 0;  
                        ShieldUsable = true;                                         
                    }

                    // Calculate new movement values
                       XSpeed -= sin(degtorad(Angle))*(YSpeed);                 
                       Ground = true;          
                              
                } else {
                    scr_character_angle(global.GravityAngle);
                    YSpeed       = 0;
                    if (not Ground) {
                        break; // no need to continue looping
                    }  
                }
                
            }

            // Wall Collision (again)
            while (scr_character_collision_right(x, y, Angle, spr_mask_mid)) {
                x -= cos(degtorad(Angle));
                y += sin(degtorad(Angle));
            }
            while (scr_character_collision_left(x, y, Angle, spr_mask_mid)) {
                x += cos(degtorad(Angle));
                y -= sin(degtorad(Angle));
            }

            scr_character_handle_tunnel_locks();              
            scr_character_handle_collectibles();             
            scr_character_handle_harmful();
            scr_character_handle_spikes();            
            scr_character_handle_obstacles();
            scr_character_handle_monitors("Side");                          
                                                                           
        if (YSpeed == 0) {
            break; // abort;
        }
         
      }                                      

   }
}
     
    // Fall off the ground if the edges aren't colliding         
       if(Ground &amp;&amp; Angle != 0){
          if(!scr_character_collision_left_edge(x, y, Angle) || !scr_character_collision_right_edge(x, y, Angle)){
             if(FloorMode == 1 || FloorMode == 3){
                GSpeed        = XSpeed;             
                YSpeed        = -(dsin(RelativeAngle) * GSpeed)                           
                LaunchedTimer = 3;     
                XSpeed        = cos(degtorad(RelativeAngle))*XSpeed;
                Ground        = false;                             
             }else{
                Ground        = false;
                YSpeed        = -sin(degtorad(Angle))*XSpeed;
                XSpeed        = cos(degtorad(Angle))*XSpeed;                   
             }
          }
       }
    
    // Get the GSpeed:   
       scr_character_movement_gspeed();
     
   }     
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>604</id>
        <kind>0</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>0</useapplyto>
        <exetype>1</exetype>
        <functionname>action_inherited</functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>other</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Accel/Decel and more X/Y Movement related stuff.

 // Exit if we're death:
    if(Action != ActionDie){

    // Input Alarm, ignores left or right input while above zero.
    // Used to stop the character from inching up steep slopes.
       if(InputAlarm &gt; 0){
          InputAlarm -= 1;
       }else{
          InputAlarm     = 0;
          AlarmDirection = 0;
       }
       
    // Accel/Decel changes:
       if(Ground){
          _Accel = XAcceleration;
          _Decel = XDeceleration;
          _Fric  = _Accel;
       }else{
          _Accel = XAcceleration * 2;
          _Decel = 0;
          _Fric  = 0;       
       }
       
   // Perform Horizontal / X Movement:
      scr_character_movement_x();
              
   // Perform Vertical / Y Movement:
      scr_character_movement_y();
            
   // Air Drag:
      if(!Ground &amp;&amp; (Action != ActionHurt) ){
         if(YSpeed &lt; 0 &amp;&amp; YSpeed &gt;= -4){
            XSpeed -= ((XSpeed / 0.125) / 256);
         }
      }           
                  
   // Floor Mode
      FloorMode = round(Angle/90) % 4;  
    }

             

            


</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Character states and actions.
//  Add all actions the character can perform, here!

  // Exit if we're death:
     if(Action != ActionDie){
scr_player_actions()
     }
  
  
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Input Lock.

 // Exit if we're death:
    if(Action != ActionDie){
       
    // Exit if we're dead or hurt:
       if(Action != ActionDie &amp;&amp; Action != ActionHurt){
              
    // Enable after jumping:
       if(InputLock_S &amp;&amp; !JumpLock &amp;&amp; Action = ActionJump){
          LockTimer = 0;
          AlarmDirection = 0;          
       }
       
    // Disable Alarm Direction when the angle is 0:
       if(AlarmDirection != 0 &amp;&amp; Angle = 0){
          AlarmDirection = 0;
       }
       
    // Disable Locks:
       if(LockTimer &lt; 1 &amp;&amp; InputLock_S = true){
          InputLock_S = false;
          
          // Enable input:
             InputLock_L = 0;
             InputLock_R = 0;
         
       }
       
    // Enable Locks:
       if(InputLock_S &amp;&amp; XSpeed &gt; 0){
          InputLock_L = 1;
          KeyRight    = 1;
       }else if(InputLock_S &amp;&amp; XSpeed &lt; 0){
                InputLock_R = 1;
                KeyLeft    = 1;
       }
       
    // Decrease lock timer:
       if(LockTimer &gt; 0){
          LockTimer -= 1;
       }
       
       }
       
    }       
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///(Invincibility) Timers &amp; Sparkle Effects.
 
 // Exit if we're death:
    if(Action != ActionDie){
          
   // Speed Shoe timer:
      if(SpeedShoeTimer &gt; -1 &amp;&amp; HasSpeedShoes == true){
         SpeedShoeTimer--
      }else{
         HasSpeedShoes  = false;
         SpeedShoeTimer = 900;
      }
   
   // If our Invincibility timer is above zero, slowly decrease from it:
      if(InvTimer &gt; -1){
         InvTimer -= 1;
         if(InvTimer == 0){
            Invincibility = 0;
            InvTimer      = 0;
         }
      }
   
   // When we're hit and collide with the ground, set a invincibility timer:
      if(Invincibility == 1 &amp;&amp; InvTimer == -1 &amp;&amp; Ground){
         InvTimer = 120;
      }
   
   // When we're super, we're always invincible:
      if(CharacterState = CharacterSuper or CharacterState = CharacterHyper){
         Invincibility =  2;
         InvTimer      = -2;
      }else{
         if(InvTimer = -2){
            Invincibility = 0;
            InvTimer      = 0;
         }
      }
      
   // Sparkles:
      if(Invincibility &gt; 1){
         if(CharacterState != CharacterHyper){
            repeat(1){
                   instance_create(x + YLen*4, y-XLen*4, obj_invincibility_sparkle)
            }
         }else{
            if(CharacterState == CharacterHyper){
               repeat(1){
                      instance_create(x + YLen*4, y-XLen*4, obj_hyper_sparkle)
               }      
            }   
         }
      }

    }
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Die from Heights.

    if(global.DeathHeight == noone){
       if(y &gt;= room_height &amp;&amp; Action != ActionDie){
          Action = ActionDie;
       }
    }else{
       if(y &gt;= global.DeathHeight &amp;&amp; Action != ActionDie){
          Action = ActionDie;
       }
    }
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Modify Palette position.

 // Default:
    if(CharacterID = CharacterSonic &amp;&amp; CharacterState = CharacterNormal &amp;&amp; TransformEnded = 0){
       PalettePosition = 0;
    }
 
 // Back to normal Sonic Palette:
    if(CharacterID = CharacterSonic &amp;&amp; CharacterState = CharacterNormal &amp;&amp; TransformEnded == 1){
       if(PalettePosition &gt;= 10){
          TransformEnded   = 0;
          PalettePosition  = 0;
       }else{
          PalettePosition += 0.50;
       }
    }
    
 // Back to normal Tails Palette:
    if(CharacterID = CharacterTails &amp;&amp; CharacterState = CharacterNormal &amp;&amp; TransformEnded == 1){
       if(PalettePosition &gt;= 6){
          TransformEnded   = 0;
          PalettePosition  = 0;
       }else{
          PalettePosition += 0.25;
       }
    }    
    
 // Back to normal Knuckles Palette:
    if(CharacterID = CharacterKnuckles &amp;&amp; CharacterState = CharacterNormal &amp;&amp; TransformEnded == 1){
       if(PalettePosition &gt;= 5){
          TransformEnded   = 0;
          PalettePosition  = 0;
       }else{
          PalettePosition += 0.25;
       }
    }  
        
 // Super Sonic Palette:
    if(CharacterID = CharacterSonic &amp;&amp; CharacterState = CharacterSuper){
       if(PalettePosition &gt; 2){
          PalettePosition = 0;
       }
       PalettePosition += 0.05;
    }
    
 // Hyper Sonic Palette:
    if(CharacterID = CharacterSonic &amp;&amp; CharacterState = CharacterHyper){
       if(PalettePosition &gt; 7){
          PalettePosition = 0;
       }
       PalettePosition += 0.10;
    }
    
 // Super Tails Palette:
    if(CharacterID = CharacterTails &amp;&amp; CharacterState != CharacterNormal){
       if(PalettePosition &gt; 9){
          PalettePosition = 0;
       }
       PalettePosition += 0.15;
    }    
    
 // Hyper Knuckles Palette:
    if(CharacterID = CharacterKnuckles &amp;&amp; CharacterState != CharacterNormal){
       if(PalettePosition &gt; 11){
          PalettePosition = 0;
       }
       PalettePosition += 0.20;
    }        
    
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Gameplay Effects.

    // After Effect:
       if(!Underwater){
          if((CharacterState = CharacterHyper &amp;&amp; current_time div 40) || (HomingUsed = true &amp;&amp; current_time div 40) | (CharacterID == CharacterAmy 
          &amp;&amp; (AmyHammerAttack = 2 || AmyHammerAttack = 3) &amp;&amp; current_time div 40)){
             if(instance_number(obj_aftereffect) &lt; 3){
                Effect = (instance_create(xprevious, yprevious, obj_aftereffect)){
                          Effect.Parent             = id;
                          Effect.sprite_index       = AnimationSprite;
                          Effect.AnimationFrame     = AnimationFrame;
                          Effect.AnimationDirection = AnimationDirection;
                          Effect.AnimationAngle     = AnimationAngle;
                }
             }
          }
       }

</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Underwater handling.
 
 // Only run this if we're not in a bonus stage, died or won a stage.
    if(Action != ActionDie &amp;&amp; GoalState != 1 &amp;&amp; !instance_exists(obj_scoring_results) &amp;&amp; !instance_exists(obj_game_over)){
    
       // Underwater:
          if(Underwater == true){
          
             // Stop this code block if we have a Bubble Shield or we're hyper:
                if(Shield == ShieldBubble &amp;&amp; CharacterState != CharacterHyper){
                   DrownTimer = 1800;
                   if(DrownCounter != -1){
                      if(instance_exists(DrownCounter)){
                         instance_destroy(DrownCounter);
                      }
                   }
                   exit;
                }
                
             // Reduce the drowning timer:
                if(DrownTimer != 0 &amp;&amp; CharacterState != CharacterHyper){
                   DrownTimer--
                }
          
             // Start the drowning theme:
                if(DrownTimer == 650){
                   if(CheckSound(obj_audio_manager.Jingle_Drowning ) == false){
                      PlaySound(obj_audio_manager.Jingle_Drowning, global.SFXVolume, 1, 1);
                   }
                   if(instance_exists(obj_water_countdown) == false){
                      DrownCounter = instance_create(x, y-32, obj_water_countdown);
                      DrownCounter.Parent = id;
                   }
                }
                
             // Kill the Character.
                if(DrownTimer == 0){
                   DrownTimer = 1800;
                   Action     = ActionDie;
                   HasDrowned = true;
                   if(CheckSound(obj_audio_manager.Jingle_Drowning)){
                      StopSound(obj_audio_manager.Jingle_Drowning);
                   }
                }
             
             // Bubble Action.
                if(Action = ActionBreath &amp;&amp; !Ground){
                   if(BubbleTimer &lt; 1){
                      XSpeed = 0;
                      YSpeed = 0;
                   }
                    if(KeyLeft or KeyRight){
                       XSpeed += AnimationDirection*.025
                    }
                   if(BubbleTimer &lt; 20){
                      BubbleTimer++
                   }else{
                      BubbleTimer = 0;
                      Animation   = "WALK";
                      Action      = ActionNormal;
                   }
                   DrownTimer = 1800;
                   if(DrownCounter != -1){
                      if(instance_exists(DrownCounter)){
                         instance_destroy(DrownCounter);
                      }
                   }
                   if(CheckSound(obj_audio_manager.Jingle_Drowning) == true){ 
                      if(Invincibility &lt; 1.5){
                         LoopSound(obj_audio_manager.ZoneBGM, global.BGMVolume, 1);   
                         global.BGMVolume = global.MaxBGMV;
                      }
                      StopSound(obj_audio_manager.Jingle_Drowning);
                   }
                }else if(Action = ActionBreath &amp;&amp; Ground){
                         Action       = ActionNormal;
                         BubbleTimer  = 0;
                }
                
             // No Bubble Action.
                if(Action != ActionBreath){
                   BubbleTimer = 0;
                } 
                
             // Alarm Sounds:
              if(DrownTimer mod 400 == 0){
                 if(CheckSound(obj_audio_manager.Jingle_Drowning) == false){
                     PlaySound(snd_object_alarm_count, global.SFXVolume, 1, 1);
                 }
              }    
                       
             // Air bubbles:
                if(DrownTimer mod 78 == 0 &amp;&amp; DrownTimer &gt; 600){
                   Bubble = instance_create(x+irandom_range(-7, 8), y-6, obj_air_bubble);
                   Bubble.BubbleIndex = choose(0, 1, 2, 1, 3);
                }
                                            
          }
          
          // Last Checks above water:
             if(Underwater == false &amp;&amp; DrownTimer != 1800){
                DrownTimer = 1800;
                DrownTimer = 1800;
                if(DrownCounter != -1){
                   if(instance_exists(DrownCounter)){
                      instance_destroy(DrownCounter);
                   }
                }
                if(CheckSound(obj_audio_manager.Jingle_Drowning) == true){ 
                   if(Invincibility &lt; 1.5){
                      LoopSound(obj_audio_manager.ZoneBGM, global.BGMVolume, 1);   
                      global.BGMVolume = global.MaxBGMV;
                   }
                   StopSound(obj_audio_manager.Jingle_Drowning);
                }
             }
       
    }
           
          // Drowning Bubbles.
             if(Action = ActionDie &amp;&amp; HasDrowned){
                if(BreathTimer != 0){
                   BreathTimer -= 0.5;
                   if(random(4) &gt;= 2){
                      Bubble = instance_create(x+irandom_range(-7, 8), y-6, obj_air_bubble);
                      Bubble.BubbleIndex = choose(0, 1, 2, 1, 3);                 
                   }
                }
             }
             
          // Prevent music from not restarting.
             if(GoalState != 1 &amp;&amp; !instance_exists(obj_scoring_results) &amp;&amp; !instance_exists(obj_game_over)){
                if(CheckSound(obj_audio_manager.Jingle_Drowning) == false &amp;&amp; CheckSound(obj_audio_manager.ZoneBGM) == false){
                   if((Action = ActionBreath or Underwater == false) &amp;&amp; Action != ActionDie &amp;&amp; DrownTimer &gt; 0 &amp;&amp; Invincibility &lt; 1.5){
                      LoopSound(obj_audio_manager.ZoneBGM, global.BGMVolume, 1);
                      global.BGMVolume = global.MaxBGMV;
                   }
                }
             }     


</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Draw and Animate the character.
      
   // Palette: (Only if we allow Shaders)
      if(global.Shaders != 0){
         // Sonic:
         if(CharacterID = CharacterSonic &amp;&amp; CharacterState = CharacterSuper){
            pal_swap_set(spr_sonic_super_palette, floor(PalettePosition), false);
         }
         if(CharacterID = CharacterSonic &amp;&amp; CharacterState = CharacterHyper){
            pal_swap_set(spr_sonic_hyper_palette, floor(PalettePosition), false);
         }    
         if(CharacterID = CharacterSonic &amp;&amp; CharacterState = CharacterNormal &amp;&amp; TransformEnded == 1){
            pal_swap_set(spr_sonic_to_normal_palette, floor(PalettePosition), false);
         }        
         // Tails:
         if(CharacterID == CharacterTails &amp;&amp; CharacterState != CharacterNormal){
            pal_swap_set(spr_tails_super_palette, floor(PalettePosition), false);
         }  
         if(CharacterID = CharacterTails &amp;&amp; CharacterState = CharacterNormal &amp;&amp; TransformEnded == 1){
            pal_swap_set(spr_tails_to_normal_palette, floor(PalettePosition), false);
         }                      
         // Knuckles
         if(CharacterID == CharacterKnuckles &amp;&amp; CharacterState != CharacterNormal){
            pal_swap_set(spr_knuckles_hyper_palette, floor(PalettePosition), false);
         }  
         if(CharacterID = CharacterKnuckles &amp;&amp; CharacterState = CharacterNormal &amp;&amp; TransformEnded == 1){
            pal_swap_set(spr_knuckles_to_normal_palette, floor(PalettePosition), false);
         }                                   
      }
      
   // Draw the Character:
      if(InvTimer &gt; 0 &amp;&amp; Invincibility == 1){
         if((global.ObjectTime div 60) mod 3){
            if(TailSprite != noone){
               draw_sprite_ext(TailSprite, floor(TailFrame), floor(x+TailX), floor(y+TailY), TailDirection, 1, TailAngle, c_white, Alpha);
            }
            draw_sprite_ext(AnimationSprite, floor(AnimationFrame), floor(x+AnimationOffsetX), floor(y+AnimationOffsetY), AnimationDirection, 1, AnimationAngle, c_white, Alpha);
         }
      }else{
            if(TailSprite != noone){
               draw_sprite_ext(TailSprite, floor(TailFrame), floor(x+TailX), floor(y+TailY), TailDirection, 1, TailAngle, c_white, Alpha);
            }     
            draw_sprite_ext(AnimationSprite, floor(AnimationFrame), floor(x+AnimationOffsetX), floor(y+AnimationOffsetY), AnimationDirection, 1, AnimationAngle, c_white, Alpha);
      }
      
   // When we modified the palette, make sure to reset it:
      if(global.Shaders != 0){
         if(CharacterState != CharacterNormal){
            pal_swap_reset()
         }
      }
   
   // Draw the Spindash Dust:
      if(Action = ActionSpindash or (Action = ActionPeelout &amp;&amp; Animation = "PEELOUT")){
         draw_sprite_ext(spr_spindash_dust, current_time div 40, floor(x-AnimationDirection*7), floor(y+13), AnimationDirection, 1, 0, c_white, 1);         
      }

</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>604</id>
        <kind>0</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>0</useapplyto>
        <exetype>1</exetype>
        <functionname>action_inherited</functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
